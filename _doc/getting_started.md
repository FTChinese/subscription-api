# Getting Started

## Base URL

* Production: `http://www.ftacademy.cn/api/v<xx>`
* Sandbox: `http://www.ftacademy.cn/api/sandbox`

## Versioning

1. In `pkg/config/version.go`, change `Version`, `Port` variable.
2. Change stripe webhook url with the following steps:
    1. Go to Stripe dashboard.
    2. Find the "Developers" configuration page.
    3. Select "Webhooks" from sidebar.
    4. Click "Add endpoint".
    5. Add new version's Stripe webhook url.
    6. Copy the "Signing secret".
    7. On your machine's configuration file `~/config/api.toml`. In the `api_keys` section, add a section like:

    ```toml
    [api_keys.stripe_webhook_v<your-current-version>]
    dev = "the test key. Simply copy it from previous versions since it won't be changed."
    prod = "the singing key you copied"
    ```
    8. Upload the configuration file to tk11 machine.
    9. Also run `make devconfig` command so that the modified configuration file is synced to your current directory so that Go's embedding of static assets works for development.
3. In makefile, change `app_name := subs-api-v<your version name>`
4. Configure URL. Map external URL to the new version's port.

| Version  | Port  | Binary name      | External URL                    |
| -------- | ----- | ---------------- |---------------------------------|
|  1       | 8200  | subscription-api | https://www.ftacademy.cn/api/v1 |
|  2       | 8202  | subs-api-v2      | https://www.ftacademy.cn/api/v2 |
|  3       | 8203  | subs-api-v3      | https://www.ftacademy.cn/api/v3 |
|  4       | 8204  | subs-api-v4      | https://www.ftacademy.cn/api/v4 |
|  5       | 8205  | subs-api-v5       | https://www.ftacademy.cn/api/v5 |
|  6       | 8206  | subs-api-v6       | https://www.ftacademy.cn/api/v6 |

## Authorization Header

To impose access restriction, all requests are required to set header `Authorization: Bearer <token>`; otherwise the request is denied.

The only exceptions are endpoints under `/webhook` which are used by other parties to send notification.

## Internal Status

* `/__version` See current program's build info

## Pitfalls

Wechat's APP ID, MCH ID must match, which means APP ID must be in your MCH ID's authorized list; otherwise you could never call wechat on you app.

32 char key is the one you entered, not generated by wechat.

## Design of subscription

### Renewal Policy

A subscribed user is only allowd to renew the next billing cycle. If the difference between current date and the expiration date is less than the billing cycle he is trying to subscribe, the user is allowed to renew subscription; otherwise, deny the request.

Example:

A user is subscribe to a yearly membership from 2018-01-01 to 2019-01-01. Today is 2018-07-01 and He is trying to extend one year more's subscription. The difference between toay (2018-07-01) to expiration date (2019-01-01) is less then a billing cycle (one year). He can renew subscription to 2020-01-01. After renewal, this user immediately tries to extend another billing cycle to 2021-01-01. This request will be denied since today (2018-07-01) to expiration date (2020-01-01) is greater than a yearly billing cycle.

The same priciple applies to monthly subscrition. A user could only buy two month consecutively at most.

### The importance of `payment_method` column

You would never be able to mix all supported payment method together without this field.

ftc_vip如下字段组合互斥：

payment_method == (alipay || wechat) 和 ftc_plan_id 同时存在 并且 auto_renewal为0;

payment_method == apple  和 apple_subscription、auto_renewal 同时存在;

payment_method == stripe 和 stripe_subscription_id、stripe_plan_id、sub_status、auto_renewal 同时存在.

## Price offer selection algorithm

[Paywall](./paywall.md)的数据结构中可以看到，每个产品下面有多个价格，每个价格下面有多个折扣价格。折扣分为四个类别：

* `promotion`: 适用于所有会员的促销活动
* `retention`: 适用于会员有效期内的会员
* `win_back`: 适用于曾经购买了但当前时间已经过期的会员
* `introductory`: 仅用于还不是会员的账号

其中，`introductory`, `retention`, `win_back` 三类互斥，一个用户在某一时间只会处于某一状态下。

步骤1：根据Membership中包含的数据推测该用户可以使用哪些折扣类别（可能包含多个）：

* 当Membership中的`tier`为`null`时，用户可能未登录，或者没有会员记录，则`promotion`和`introductory`均适用
* 如果`tier`不是`null`，则检测是否已经过期，过期的标准是`expireDate`在今天之前，并且`autoRenew`是`false`。如果已经过期，则属于`promotion` 或者`win_back`。
* 如果未过期，则属于`promotion`或者`retention`。

步骤2：筛选出一个价格下的有效折扣。如果一个折扣未设置起止时间，则为永久性折扣，始终有效；如果有起止时间，则当前时刻处于起止时间中的折扣才有效。有效折扣可能会有多个。

步骤3：以步骤1中的折扣类别，进一步筛选步骤2中的结果，留下所有符合步骤1类别的折扣。

步骤4：按照折扣中的`priceOff`字段，从大到小排序，排在第一位是用户可以获得的最高折扣，这就是一个用户在该价格下适用的优惠。

因此，设置折扣时，同一种类别实际上可以设置多个折扣。如标准年度版为例，存在一个`retention`类别的永久性折扣，减去80元。如果我们再设置一个同类别的折扣，减去的折扣设为100元，起止时间设为 2021-11-10T16:00:00Z 到
2021-11-11T16:00:00Z（即东八区11月11日当天全天），对于一个未过期会员，减80和减100两个折扣都适用，由于我们只取折扣价最高者，所以会使用减100的折扣。

假设，我们在当天又设置了一个promotion的折扣价，减去99元，该会员依然会看到减100的价格，而不是减99的价格。
